// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`library dts test > matches the index.d.ts snapshot 1`] = `
"import CacheLib from 'cache-control-parser';
import { W as WorkerClass, M as Method, a as Worker, b as Middleware } from './middleware-CfKw8AlN.js';
export { D as DELETE, G as GET, H as HEAD, O as OPTIONS, d as PATCH, c as POST, P as PUT } from './middleware-CfKw8AlN.js';
import { MatchFunction } from 'path-to-regexp';
export { C as CustomEventMap, a as CustomEventType, E as EventOptions, d as ExtendedEventListener, b as ExtendedEventMap, c as ExtendedEventType, e as WSAttachment, W as WarnEvent, f as WebSocketConnection } from './websocket-DR6W2q9z.js';

/**
 * @see {@link https://github.com/etienne-martin/cache-control-parser | cache-control-parser}
 */
type CacheControl = CacheLib.CacheControl;
declare const CacheControl: {
    parse: (cacheControlHeader: string) => CacheLib.CacheControl;
    stringify: (cacheControl: CacheLib.CacheControl) => string;
    /** A CacheControl directive that disables all caching. */
    DISABLE: Readonly<{
        "no-cache": true;
        "no-store": true;
        "must-revalidate": true;
        "max-age": 0;
    }>;
};

/**
 * https://github.com/prettymuchbryce/http-status-codes
 */
declare enum StatusCodes {
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.1
     *
     * This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.
     */
    CONTINUE = 100,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.2
     *
     * This code is sent in response to an Upgrade request header by the client, and indicates the protocol the server is switching too.
     */
    SWITCHING_PROTOCOLS = 101,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.1
     *
     * This code indicates that the server has received and is processing the request, but no response is available yet.
     */
    PROCESSING = 102,
    /**
     * Official Documentation @ https://www.rfc-editor.org/rfc/rfc8297#page-3
     *
     * This code indicates to the client that the server is likely to send a final response with the header fields included in the informational response.
     */
    EARLY_HINTS = 103,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.1
     *
     * The request has succeeded. The meaning of a success varies depending on the HTTP method:
     * GET: The resource has been fetched and is transmitted in the message body.
     * HEAD: The entity headers are in the message body.
     * POST: The resource describing the result of the action is transmitted in the message body.
     * TRACE: The message body contains the request message as received by the server
     */
    OK = 200,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.2
     *
     * The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a PUT request.
     */
    CREATED = 201,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.3
     *
     * The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.
     */
    ACCEPTED = 202,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.4
     *
     * This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.
     */
    NON_AUTHORITATIVE_INFORMATION = 203,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.5
     *
     * There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.
     */
    NO_CONTENT = 204,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.6
     *
     * This response code is sent after accomplishing request to tell user agent reset document view which sent this request.
     */
    RESET_CONTENT = 205,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.1
     *
     * This response code is used because of range header sent by the client to separate download into multiple streams.
     */
    PARTIAL_CONTENT = 206,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.2
     *
     * A Multi-Status response conveys information about multiple resources in situations where multiple status codes might be appropriate.
     */
    MULTI_STATUS = 207,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.1
     *
     * The request has more than one possible responses. User-agent or user should choose one of them. There is no standardized way to choose one of the responses.
     */
    MULTIPLE_CHOICES = 300,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.2
     *
     * This response code means that URI of requested resource has been changed. Probably, new URI would be given in the response.
     */
    MOVED_PERMANENTLY = 301,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.3
     *
     * This response code means that URI of requested resource has been changed temporarily. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.
     */
    FOUND = 302,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.4
     *
     *  The 302 (Found) status code indicates that the target resource resides temporarily under a different URI.  Since the redirection might be altered on occasion, the client ought to continue to use the effective request URI for future requests.
     */
    SEE_OTHER = 303,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.1
     *
     * This is used for caching purposes. It is telling to client that response has not been modified. So, client can continue to use same cached version of response.
     */
    NOT_MODIFIED = 304,
    /**
     * @deprecated
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.6
     *
     * Was defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.
     */
    USE_PROXY = 305,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.7
     *
     * Server sent this response to directing client to get requested resource to another URI with same method that used prior request. This has the same semantic than the 302 Found HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
     */
    TEMPORARY_REDIRECT = 307,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7538#section-3
     *
     * This means that the resource is now permanently located at another URI, specified by the Location: HTTP Response header. This has the same semantics as the 301 Moved Permanently HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
     */
    PERMANENT_REDIRECT = 308,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.1
     *
     * This response means that server could not understand the request due to invalid syntax.
     */
    BAD_REQUEST = 400,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.1
     *
     * Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response.
     */
    UNAUTHORIZED = 401,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.2
     *
     * This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.
     */
    PAYMENT_REQUIRED = 402,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.3
     *
     * The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.
     */
    FORBIDDEN = 403,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.4
     *
     * The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurrence on the web.
     */
    NOT_FOUND = 404,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.5
     *
     * The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, GET and HEAD, must never be disabled and should not return this error code.
     */
    METHOD_NOT_ALLOWED = 405,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.6
     *
     * This response is sent when the web server, after performing server-driven content negotiation, doesn't find any content following the criteria given by the user agent.
     */
    NOT_ACCEPTABLE = 406,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.2
     *
     * This is similar to 401 but authentication is needed to be done by a proxy.
     */
    PROXY_AUTHENTICATION_REQUIRED = 407,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.7
     *
     * This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.
     */
    REQUEST_TIMEOUT = 408,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.8
     *
     * This response is sent when a request conflicts with the current state of the server.
     */
    CONFLICT = 409,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.9
     *
     * This response would be sent when the requested content has been permenently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for "limited-time, promotional services". APIs should not feel compelled to indicate resources that have been deleted with this status code.
     */
    GONE = 410,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.10
     *
     * The server rejected the request because the Content-Length header field is not defined and the server requires it.
     */
    LENGTH_REQUIRED = 411,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.2
     *
     * The client has indicated preconditions in its headers which the server does not meet.
     */
    PRECONDITION_FAILED = 412,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.11
     *
     * Request entity is larger than limits defined by server; the server might close the connection or return an Retry-After header field.
     */
    REQUEST_TOO_LONG = 413,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.12
     *
     * The URI requested by the client is longer than the server is willing to interpret.
     */
    REQUEST_URI_TOO_LONG = 414,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.13
     *
     * The media format of the requested data is not supported by the server, so the server is rejecting the request.
     */
    UNSUPPORTED_MEDIA_TYPE = 415,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.4
     *
     * The range specified by the Range header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.
     */
    REQUESTED_RANGE_NOT_SATISFIABLE = 416,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.14
     *
     * This response code means the expectation indicated by the Expect request header field can't be met by the server.
     */
    EXPECTATION_FAILED = 417,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2324#section-2.3.2
     *
     * Any attempt to brew coffee with a teapot should result in the error code "418 I'm a teapot". The resulting entity body MAY be short and stout.
     */
    IM_A_TEAPOT = 418,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
     *
     * The 507 (Insufficient Storage) status code means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request. This condition is considered to be temporary. If the request which received this status code was the result of a user action, the request MUST NOT be repeated until it is requested by a separate user action.
     */
    INSUFFICIENT_SPACE_ON_RESOURCE = 419,
    /**
     * @deprecated
     * Official Documentation @ https://tools.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-webdav-protocol-06.txt
     *
     * A deprecated response used by the Spring Framework when a method has failed.
     */
    METHOD_FAILURE = 420,
    /**
     * Official Documentation @ https://datatracker.ietf.org/doc/html/rfc7540#section-9.1.2
     *
     * Defined in the specification of HTTP/2 to indicate that a server is not able to produce a response for the combination of scheme and authority that are included in the request URI.
     */
    MISDIRECTED_REQUEST = 421,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.3
     *
     * The request was well-formed but was unable to be followed due to semantic errors.
     */
    UNPROCESSABLE_ENTITY = 422,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.4
     *
     * The resource that is being accessed is locked.
     */
    LOCKED = 423,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.5
     *
     * The request failed due to failure of a previous request.
     */
    FAILED_DEPENDENCY = 424,
    /**
     * Official Documentation @ https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.15
     *
     * The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.
     */
    UPGRADE_REQUIRED = 426,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-3
     *
     * The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.
     */
    PRECONDITION_REQUIRED = 428,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-4
     *
     * The user has sent too many requests in a given amount of time ("rate limiting").
     */
    TOO_MANY_REQUESTS = 429,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-5
     *
     * The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.
     */
    REQUEST_HEADER_FIELDS_TOO_LARGE = 431,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7725
     *
     * The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.
     */
    UNAVAILABLE_FOR_LEGAL_REASONS = 451,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.1
     *
     * The server encountered an unexpected condition that prevented it from fulfilling the request.
     */
    INTERNAL_SERVER_ERROR = 500,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.2
     *
     * The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD.
     */
    NOT_IMPLEMENTED = 501,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.3
     *
     * This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.
     */
    BAD_GATEWAY = 502,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.4
     *
     * The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the Retry-After: HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.
     */
    SERVICE_UNAVAILABLE = 503,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.5
     *
     * This error response is given when the server is acting as a gateway and cannot get a response in time.
     */
    GATEWAY_TIMEOUT = 504,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.6
     *
     * The HTTP version used in the request is not supported by the server.
     */
    HTTP_VERSION_NOT_SUPPORTED = 505,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
     *
     * The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.
     */
    INSUFFICIENT_STORAGE = 507,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-6
     *
     * The 511 status code indicates that the client needs to authenticate to gain network access.
     */
    NETWORK_AUTHENTICATION_REQUIRED = 511
}

/**
 * Time constants in seconds. Month is approximated as 30 days.
 */
declare const Time: {
    readonly Second: 1;
    readonly Minute: 60;
    readonly Hour: 3600;
    readonly Day: 86400;
    readonly Week: 604800;
    readonly Month: 2592000;
    readonly Year: 31536000;
};

/**
 * Structure for JSON-formatted error responses.
 *
 * This interface defines the standard shape of error responses returned
 * when an operation fails. It ensures consistent error reporting and easy
 * parsing by clients.
 */
interface ErrorJson {
    /**
     * HTTP status code associated with the error.
     *
     * Example: \`404\` for Not Found, \`500\` for Internal Server Error.
     */
    status: number;
    /**
     * Standard HTTP reason phrase corresponding to the status code.
     *
     * Example: \`"Not Found"\` for 404, \`"Internal Server Error"\` for 500.
     */
    error: string;
    /**
     * Optional detailed message describing the error.
     *
     * This can include additional context, debugging hints, or
     * information useful to the client. Will be an empty string
     * if no details are provided.
     */
    details: string;
}

/**
 * A type-safe Cloudflare Worker handler with a guaranteed \`fetch\` method.
 */
interface FetchHandler {
    /**
     * Handles an incoming request and produces a response.
     *
     * @param request - The incoming \`Request\` object.
     * @param env - User-provided environment bindings.
     * @param ctx - Execution context for background tasks (\`waitUntil\`).
     * @returns A \`Promise\` that resolves to a \`Response\`.
     */
    fetch: (request: Request, env: Env, ctx: ExecutionContext) => Promise<Response>;
}

/**
 * Initialization options for an OctetStream response.
 *
 * @property size - Total size of the data (required).
 * @property offset - Start of the byte range (optional, defaults to 0).
 * @property length - Length of the byte range (optional, defaults to size).
 */
interface OctetStreamInit {
    size: number;
    offset?: number;
    length?: number;
}

/**
 * Parameters extracted from a matched route.
 *
 * The keys correspond to named parameters in the route's path pattern,
 * and the values are the strings captured from the URL.
 *
 * @example
 * // For a route defined as "/users/:userId/posts/:postId"
 * // and a URL "/users/42/posts/7", the extracted PathParams would be:
 * const params: PathParams = {
 *   userId: "42",
 *   postId: "7"
 * };
 */
type PathParams = Record<string, string>;
/**
 * Type for a route callback function.
 *
 * Route callbacks are executed when a request matches a route.
 *
 * @param params - Named parameters extracted from the URL path.
 * @returns A Response object or a Promise resolving to a Response.
 */
type RouteCallback = (params: PathParams) => Response | Promise<Response>;
/**
 * A handler for a route, which can be either:
 *
 * 1. \`RouteCallback\` function that receives the route
 *    parameters and returns a \`Response\` or \`Promise<Response>\`.
 * 2. \`WorkerClass\` (subclass of \`Worker\`) that will handle
 *    the request by instantiating a new worker.
 */
type RouteHandler = RouteCallback | WorkerClass;
/**
 * Represents a single route.
 *
 * Contains all necessary information to match an incoming request and
 * pass to the registered handler.
 */
interface Route {
    /** HTTP method for the route (e.g., \`GET\`, \`POST\`, etc.) */
    method: Method;
    /** Path-to-regexp matcher function for this route */
    matcher: MatchFunction<PathParams>;
    /** Function or Worker to execute or instantiate when the route is matched */
    handler: RouteHandler;
}
/**
 * Result of a route match.
 *
 * Returned by routing logic when a request matches a route pattern.
 */
interface MatchedRoute {
    /** The route that matched the request */
    route: Route;
    /** Parameters extracted from the URL path */
    params: PathParams;
}
/**
 * A route tuple. Each tuple consists of:
 *
 * 1. HTTP method (e.g., \`GET\`, \`POST\`)
 * 2. Path string (supports parameters, e.g., "/users/:id")
 * 3. Callback function or Worker class to handle matched requests
 * */
type RouteTuple = [Method, string, RouteHandler];
/**
 * Iterable of route tuples, used to populate a \`Routes\` object.
 *
 * Each item yields a {@link RouteTuple} representing a single route.
 *
 * @see {@link RouteTuple}
 */
type RouteTable = Iterable<RouteTuple>;

/**
 * Provides the foundational structure for handling requests,
 * environment bindings, and the worker execution context.
 *
 * Features:
 * - Holds the current \`Request\` object (\`request\` getter).
 * - Provides access to environment bindings (\`env\` getter).
 * - Provides access to the worker execution context (\`ctx\` getter).
 * - Subclasses must implement \`fetch()\` to process the request.
 */
declare abstract class BaseWorker implements Worker {
    private readonly _request;
    private readonly _env;
    private readonly _ctx;
    constructor(_request: Request, _env: Env, _ctx: ExecutionContext);
    /** The Request object associated with this worker invocation */
    get request(): Request;
    /** Environment bindings (e.g., KV, secrets, or other globals) */
    get env(): Env;
    /** Execution context for background tasks or \`waitUntil\` */
    get ctx(): ExecutionContext;
    /**
     * Dispatches the incoming request to the appropriate handler and produces a response.
     *
     * Subclasses must implement this method to define how the worker generates a \`Response\`
     * for the current request. This is the central point where request processing occurs.
     *
     * @returns A Promise that resolves to the \`Response\` for the request.
     */
    protected abstract dispatch(): Promise<Response>;
    /**
     * Determines whether a given HTTP method is allowed for this worker.
     *
     * - GET and HEAD are **always allowed**, in compliance with RFC 9110,
     *   even if they are not explicitly listed in \`getAllowedMethods()\`.
     * - Other methods are allowed only if included in the array returned by
     *   \`getAllowedMethods()\` and are valid HTTP methods.
     *
     * @param method - The HTTP method to check (e.g., "GET", "POST").
     * @returns \`true\` if the method is allowed, \`false\` otherwise.
     */
    isAllowed(method: string): boolean;
    abstract getAllowedMethods(): Method[];
    /**
     * Creates a new instance of the current Worker subclass.
     *
     * @param request - The {@link Request} to pass to the new worker instance.
     * @returns A new worker instance of the same subclass as \`this\`.
     */
    protected create(request: Request): this;
    /**
     * Process the {@link Request} and produce a {@link Response}.
     *
     * @returns A {@link Response} promise for the {@link Request}.
     */
    abstract fetch(): Promise<Response>;
    /**
     * Simplify and standardize {@link Response} creation by extending {@link WorkerResponse}
     * or any of its subclasses and passing to this method.
     *
     * Or directly use any of the built-in classes.
     *
     * \`\`\`ts
     * this.response(TextResponse, "Hello World!")
     * \`\`\`
     *
     * @param ResponseClass The response class to instantiate
     * @param args Additional constructor arguments
     * @returns A Promise resolving to the {@link Response} object
     */
    protected response<Ctor extends new (...args: any[]) => {
        response(): Promise<Response>;
    }>(ResponseClass: Ctor, ...args: ConstructorParameters<Ctor>): Promise<Response>;
    /**
     * **Ignite** your \`Worker\` implementation into a Cloudflare handler.
     *
     * @returns A \`FetchHandler\` that launches a new worker instance for each request.
     *
     * \`\`\`ts
     * export default MyWorker.ignite();
     * \`\`\`
     */
    static ignite<W extends Worker>(this: WorkerClass<W>): FetchHandler;
}

/** Base worker for handling middleware chains. */
declare abstract class MiddlewareWorker extends BaseWorker {
    /** Middleware handlers registered for this worker. */
    protected readonly middlewares: Middleware[];
    /**
     * Hook for subclasses to perform any initialization.
     */
    protected init(): void | Promise<void>;
    /**
     * Add one or more middleware instances to this worker.
     *
     * The middleware will run for every request handled by this worker,
     * in the order they are added.
     *
     * @param middleware - One or more middleware instances to run.
     * @returns \`this\` to allow chaining multiple \`.use()\` calls.
     */
    use(...middleware: Middleware[]): this;
    /**
     * Executes the middleware chain and dispatches the request if the method
     * is allowed by the worker.
     *
     * @returns The Response produced by the last middleware or \`dispatch()\`.
     */
    fetch(): Promise<Response>;
}

/**
 * Basic worker class providing HTTP method dispatching and error handling.
 */
declare abstract class BasicWorker extends MiddlewareWorker {
    /**
     * Entry point to handle a fetch request.
     */
    fetch(): Promise<Response>;
    /**
     * Dispatches the request to the method-specific handler.
     */
    protected dispatch(): Promise<Response>;
    /** Override and implement this method for \`GET\` requests. */
    protected get(): Promise<Response>;
    /** Override and implement this method for \`PUT\` requests. */
    protected put(): Promise<Response>;
    /** Override and implement this method for \`POST\` requests. */
    protected post(): Promise<Response>;
    /** Override and implement this method for \`PATCH\` requests. */
    protected patch(): Promise<Response>;
    /** Override and implement this method for \`DELETE\` requests. */
    protected delete(): Promise<Response>;
    /** Returns the default \`OPTIONS\` response. */
    protected options(): Promise<Response>;
    /**
     * Default handler for \`HEAD\` requests.
     * Performs a \`GET\` request and removes the body for \`HEAD\` semantics.
     *
     * Usually does not need to be overridden as this behavior covers
     * standard \`HEAD\` requirements.
     */
    protected head(): Promise<Response>;
    /**
     * Returns the HTTP methods allowed by this worker.
     *
     * - GET and HEAD are always allowed per RFC 9110, even if subclasses do not include them here.
     * - OPTIONS is included by default since a default handler is implemented.
     * - Subclasses can override this method to allow additional methods or change the defaults.
     */
    getAllowedMethods(): Method[];
}

/**
 * Base worker supporting route-based request handling.
 *
 * Subclass \`RouteWorker\` to define a worker with multiple route handlers.
 *
 * Routes can be registered individually via \`route()\` or in bulk via \`routes()\`.
 */
declare abstract class RouteWorker extends BasicWorker {
    /** Internal table of registered routes. */
    private readonly _routes;
    /**
     * Registers a single new route in the worker.
     *
     * When a request matches the specified method and path, the provided handler
     * will be executed. The handler can be either:
     * - A function that receives URL parameters, or
     * - A Worker subclass that will handle the request.
     *
     * @param method  - HTTP method for the route (\`GET\`, \`POST\`, etc.).
     * @param path    - URL path pattern (path-to-regexp, e.g., "/users/:id").
     * @param handler - The function or Worker class to run when the route matches.
     * @returns The current worker instance, allowing method chaining.
     */
    protected route(method: Method, path: string, handler: RouteHandler): this;
    /**
     * Registers multiple routes at once in the worker.
     *
     * Each route should be a tuple \`[method, path, handler]\` where:
     * - \`method\`  - HTTP method for the route (\`GET\`, \`POST\`, etc.).
     * - \`path\`    - URL path pattern (path-to-regexp e.g., "/users/:id").
     * - \`handler\` - A function that receives URL parameters or a Worker subclass
     *               that will handle the request.
     *
     * @param routes - An iterable of routes to register. Each item is a \`[method, path, handler]\` tuple.
     * @returns The current worker instance, allowing method chaining.
     */
    protected routes(routes: RouteTable): this;
    /**
     * Matches the incoming request against registered routes and dispatches it.
     *
     * If a route is found:
     * - If the handler is a Worker class, a new instance is created and its \`fetch()\` is called.
     * - If the handler is a callback function, it is invoked with the extracted path parameters.
     *
     * If no route matches, the request is passed to the superclass ({@link BasicWorker})
     * \`dispatch()\` handler.
     *
     * @returns A \`Promise<Response>\` from the matched handler or parent dispatch.
     */
    protected dispatch(): Promise<Response>;
    /**
     * Runtime type guard to check if a given handler is a Worker class.
     *
     * A Worker class is any class that extends \`BaseWorker\`.
     *
     * @param handler - The constructor function to test.
     * @returns \`true\` if \`handler\` is a subclass of \`BaseWorker\` at runtime, \`false\` otherwise.
     */
    private static isWorkerClass;
    protected put(): Promise<Response>;
    protected post(): Promise<Response>;
    protected patch(): Promise<Response>;
    protected delete(): Promise<Response>;
}

/**
 * Base class for building HTTP responses.
 * Manages headers, status, and media type.
 */
declare abstract class BaseResponse {
    /** HTTP headers for the response. */
    headers: Headers;
    /** HTTP status code (default 200 OK). */
    status: StatusCodes;
    /** Optional status text. Defaults to standard reason phrase. */
    statusText?: string;
    /** Optional websocket property. */
    webSocket?: WebSocket | null;
    /** Default media type of the response body. */
    mediaType: string;
    /** Converts current state to ResponseInit for constructing a Response. */
    protected get responseInit(): ResponseInit;
    /** Sets a header, overwriting any existing value. */
    setHeader(key: string, value: string | string[]): void;
    /** Merges a header with existing values (does not overwrite). */
    mergeHeader(key: string, value: string | string[]): void;
    /** Adds a Content-Type header if not already existing (does not overwrite). */
    addContentType(): void;
    /**
     * Removes headers that are disallowed or discouraged based on the current
     * status code.
     *
     * - **204 No Content:** strips headers that "should not" be sent
     *   (\`Content-Length\`, \`Content-Range\`), per the HTTP spec.
     * - **304 Not Modified:** strips headers that "must not" be sent
     *   (\`Content-Type\`, \`Content-Length\`, \`Content-Range\`, etc.), per the HTTP spec.
     *
     * This ensures that responses remain compliant with HTTP/1.1 standards while preserving
     * custom headers that are allowed.
     */
    filterHeaders(): void;
}
/**
 * Base response class that adds caching headers.
 */
declare abstract class CacheResponse extends BaseResponse {
    cache?: CacheControl | undefined;
    constructor(cache?: CacheControl | undefined);
    /** Adds Cache-Control header if caching is configured. */
    protected addCacheHeader(): void;
}
/**
 * Core response. Combines caching, and content type headers.
 */
declare abstract class WorkerResponse extends CacheResponse {
    private readonly body;
    constructor(body?: BodyInit | null, cache?: CacheControl);
    /** Builds the Response with body, headers, and status. */
    response(): Promise<Response>;
}
/**
 * Copies an existing response for mutation. Pass in a CacheControl
 * to be used for the response, overriding any existing \`cache-control\`
 * on the source response.
 */
declare class CopyResponse extends WorkerResponse {
    constructor(response: Response, cache?: CacheControl);
}
/**
 * Copies the response, but with null body and status 304 Not Modified.
 */
declare class NotModified extends WorkerResponse {
    constructor(response: Response);
}
/**
 * Represents a successful response with customizable body, cache and status.
 */
declare class SuccessResponse extends WorkerResponse {
    constructor(body?: BodyInit | null, cache?: CacheControl, status?: StatusCodes);
}
/**
 * JSON response. Automatically sets Content-Type to application/json.
 */
declare class JsonResponse extends SuccessResponse {
    constructor(json?: unknown, cache?: CacheControl, status?: StatusCodes);
}
/**
 * HTML response. Automatically sets Content-Type to text/html.
 */
declare class HtmlResponse extends SuccessResponse {
    constructor(body: string, cache?: CacheControl, status?: StatusCodes, charset?: string);
}
/**
 * Plain text response. Automatically sets Content-Type to text/plain.
 */
declare class TextResponse extends SuccessResponse {
    constructor(body: string, cache?: CacheControl, status?: StatusCodes, charset?: string);
}
/**
 * Represents an HTTP response for serving binary data as \`application/octet-stream\`.
 *
 * This class wraps a \`ReadableStream\` and sets all necessary headers for both
 * full and partial content responses, handling range requests in a hybrid way
 * to maximize browser and CDN caching.
 *
 * Key behaviors:
 * - \`Content-Type\` is set to \`application/octet-stream\`.
 * - \`Accept-Ranges: bytes\` is always included.
 * - \`Content-Length\` is always set to the validated length of the response body.
 * - If the request is a true partial range (offset > 0 or length < size), the response
 *   will be \`206 Partial Content\` with the appropriate \`Content-Range\` header.
 * - If the requested range covers the entire file (even if a Range header is present),
 *   the response will return \`200 OK\` to enable browser and edge caching.
 * - Zero-length streams (\`size = 0\`) are never treated as partial.
 * - Special case: a requested range of \`0-0\` on a non-empty file is normalized to 1 byte.
 */
declare class OctetStream extends WorkerResponse {
    constructor(stream: ReadableStream, init: OctetStreamInit, cache?: CacheControl);
    /**
     * Normalizes a partially-specified \`OctetStreamInit\` into a fully-specified object.
     *
     * Ensures that all required fields (\`size\`, \`offset\`, \`length\`) are defined:
     * - \`offset\` defaults to 0 if not provided.
     * - \`length\` defaults to \`size - offset\` if not provided.
     * - Special case: if \`offset\` and \`length\` are both 0 but \`size > 0\`, \`length\` is set to 1
     *   to avoid zero-length partial streams.
     *
     * @param init - The initial \`OctetStreamInit\` object, possibly with missing \`offset\` or \`length\`.
     * @returns A fully-specified \`OctetStreamInit\` object with \`size\`, \`offset\`, and \`length\` guaranteed.
     */
    private static normalizeInit;
    /**
     * Determines whether the given \`OctetStreamInit\` represents a partial range.
     *
     * Partial ranges are defined as any range that does **not** cover the entire file:
     * - If \`size === 0\`, the stream is never partial.
     * - If \`offset === 0\` and \`length === size\`, the stream is treated as a full file (not partial),
     *   even if a Range header is present. This enables browser and CDN caching.
     * - All other cases are considered partial, and will result in a \`206 Partial Content\` response.
     *
     * @param init - A fully-normalized \`OctetStreamInit\` object.
     * @returns \`true\` if the stream represents a partial range; \`false\` if it represents the full file.
     */
    private static isPartial;
}
/**
 * A streaming response for Cloudflare R2 objects.
 *
 * **Partial content support:** To enable HTTP 206 streaming, you must provide
 * request headers containing the \`Range\` header when calling the R2 bucket's \`get()\` method.
 *
 * Example:
 * \`\`\`ts
 * const stream = await this.env.R2_BUCKET.get("key", { range: this.request.headers });
 * \`\`\`
 *
 * @param source - The R2 object to stream.
 * @param cache - Optional caching override.
 */
declare class R2ObjectStream extends OctetStream {
    constructor(source: R2ObjectBody, cache?: CacheControl);
    /**
     * Computes an \`OctetStreamInit\` object from a given R2 range.
     *
     * This function normalizes a Cloudflare R2 \`R2Range\` into the shape expected
     * by \`OctetStream\`. It handles the following cases:
     *
     * - No range provided: returns \`{ size }\` (full content).
     * - \`suffix\` range: calculates the offset and length from the end of the file.
     * - Explicit \`offset\` and/or \`length\`: passed through as-is.
     *
     * @param size - The total size of the file/object.
     * @param range - Optional range to extract (from R2). Can be:
     *   - \`{ offset: number; length?: number }\`
     *   - \`{ offset?: number; length: number }\`
     *   - \`{ suffix: number }\`
     * @returns An \`OctetStreamInit\` object suitable for \`OctetStream\`.
     */
    private static computeRange;
}
/**
 * Response for WebSocket upgrade requests.
 * Automatically sets status to 101 and attaches the client socket.
 */
declare class WebSocketUpgrade extends WorkerResponse {
    constructor(client: WebSocket);
}
/**
 * Response for \`HEAD\` requests. Copy headers and status from a \`GET\` response
 * without the body.
 */
declare class Head extends WorkerResponse {
    constructor(get: Response);
}
/**
 * Response for \`OPTIONS\` requests.
 */
declare class Options extends WorkerResponse {
    constructor(worker: Worker);
}

/**
 * Generic HTTP error response.
 * Sends a JSON body with status, error message, and details.
 */
declare class HttpError extends JsonResponse {
    protected readonly details?: string | undefined;
    /**
     * @param worker The worker handling the request.
     * @param status HTTP status code.
     * @param details Optional detailed error message.
     */
    constructor(status: StatusCodes, details?: string | undefined);
}
/**
 * Creates a structured error response without exposing the error
 * details to the client. Links the sent response to the logged
 * error via a generated correlation ID.
 *
 * Status defaults to 500 Internal Server Error.
 */
declare class LoggedHttpError extends HttpError {
    constructor(error: unknown, status?: StatusCodes);
}
/** 400 Bad Request error response. */
declare class BadRequest extends HttpError {
    constructor(details?: string);
}
/** 401 Unauthorized error response. */
declare class Unauthorized extends HttpError {
    constructor(details?: string);
}
/** 403 Forbidden error response. */
declare class Forbidden extends HttpError {
    constructor(details?: string);
}
/** 404 Not Found error response. */
declare class NotFound extends HttpError {
    constructor(details?: string);
}
/** 405 Method Not Allowed error response. */
declare class MethodNotAllowed extends HttpError {
    constructor(worker: Worker);
}
/** 412 Precondition Failed error response */
declare class PreconditionFailed extends HttpError {
    constructor(details?: string);
}
/** 426 Upgrade Required error response. */
declare class UpgradeRequired extends HttpError {
    constructor();
}
/** 500 Internal Server Error response. */
declare class InternalServerError extends HttpError {
    constructor(details?: string);
}
/** 501 Not Implemented error response. */
declare class NotImplemented extends HttpError {
    constructor(details?: string);
}
/** 501 Method Not Implemented error response for unsupported HTTP methods. */
declare class MethodNotImplemented extends NotImplemented {
    constructor(worker: Worker);
}
/** 503 Service Unavailable error response. */
declare class ServiceUnavailable extends HttpError {
    constructor(details?: string);
}

export { BadRequest, BasicWorker, CacheControl, CopyResponse, type ErrorJson, type FetchHandler, Forbidden, Head, HtmlResponse, HttpError, InternalServerError, JsonResponse, LoggedHttpError, type MatchedRoute, Method, MethodNotAllowed, MethodNotImplemented, Middleware, NotFound, NotImplemented, NotModified, OctetStream, type OctetStreamInit, Options, type PathParams, PreconditionFailed, R2ObjectStream, type Route, type RouteCallback, type RouteHandler, type RouteTable, type RouteTuple, RouteWorker, ServiceUnavailable, StatusCodes, SuccessResponse, TextResponse, Time, Unauthorized, UpgradeRequired, WebSocketUpgrade, Worker, WorkerClass, WorkerResponse };
"
`;
