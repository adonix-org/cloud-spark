// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`library dts test > matches the index.d.ts snapshot 1`] = `
"import CacheLib from 'cache-control-parser';
import { MatchFunction } from 'path-to-regexp';
import { StatusCodes } from 'http-status-codes';
export { StatusCodes } from 'http-status-codes';

/**
 * @see {@link https://github.com/etienne-martin/cache-control-parser | cache-control-parser}
 */
type CacheControl = CacheLib.CacheControl;
declare const CacheControl: {
    parse: (cacheControlHeader: string) => CacheLib.CacheControl;
    stringify: (cacheControl: CacheLib.CacheControl) => string;
    /** A CacheControl directive that disables all caching. */
    DISABLE: Readonly<{
        "no-cache": true;
        "no-store": true;
        "must-revalidate": true;
        "max-age": 0;
    }>;
};

/**
 * https://github.com/prettymuchbryce/http-status-codes
 */

/**
 * Standard HTTP header names and common values.
 */
declare namespace HttpHeader {
    const ALLOW = "Allow";
    const ACCEPT_ENCODING = "Accept-Encoding";
    const ORIGIN = "Origin";
    const CONTENT_TYPE = "Content-Type";
    const CACHE_CONTROL = "Cache-Control";
    const USER_AGENT = "User-Agent";
    const VARY = "Vary";
    const CONTENT_SECURITY_POLICY = "Content-Security-Policy";
    const PERMISSIONS_POLICY = "Permissions-Policy";
    const STRICT_TRANSPORT_SECURITY = "Strict-Transport-Security";
    const REFERRER_POLICY = "Referrer-Policy";
    const X_CONTENT_TYPE_OPTIONS = "X-Content-Type-Options";
    const X_FRAME_OPTIONS = "X-Frame-Options";
    const ACCESS_CONTROL_ALLOW_CREDENTIALS = "Access-Control-Allow-Credentials";
    const ACCESS_CONTROL_ALLOW_HEADERS = "Access-Control-Allow-Headers";
    const ACCESS_CONTROL_ALLOW_METHODS = "Access-Control-Allow-Methods";
    const ACCESS_CONTROL_ALLOW_ORIGIN = "Access-Control-Allow-Origin";
    const ACCESS_CONTROL_EXPOSE_HEADERS = "Access-Control-Expose-Headers";
    const ACCESS_CONTROL_MAX_AGE = "Access-Control-Max-Age";
    const ACCESS_CONTROL_REQUEST_HEADERS = "Access-Control-Request-Headers";
    const SEC_WEBSOCKET_VERSION = "Sec-WebSocket-Version";
    const CONNECTION = "Connection";
    const UPGRADE = "Upgrade";
}
/**
 * Standard HTTP request methods.
 */
declare enum Method {
    GET = "GET",
    PUT = "PUT",
    HEAD = "HEAD",
    POST = "POST",
    PATCH = "PATCH",
    DELETE = "DELETE",
    OPTIONS = "OPTIONS"
}
/**
 * Shorthand constants for each HTTP method.
 *
 * These are equivalent to the corresponding enum members in \`Method\`.
 * For example, \`GET === Method.GET\`.
 */
declare const GET: Method;
declare const PUT: Method;
declare const HEAD: Method;
declare const POST: Method;
declare const PATCH: Method;
declare const DELETE: Method;
declare const OPTIONS: Method;

/**
 * Common media types used for HTTP headers.
 */
declare enum MediaType {
    PLAIN_TEXT = "text/plain",
    HTML = "text/html",
    CSS = "text/css",
    CSV = "text/csv",
    XML = "text/xml",
    MARKDOWN = "text/markdown",
    RICH_TEXT = "text/richtext",
    JSON = "application/json",
    XML_APP = "application/xml",
    YAML = "application/x-yaml",
    FORM_URLENCODED = "application/x-www-form-urlencoded",
    NDJSON = "application/x-ndjson",
    MSGPACK = "application/x-msgpack",
    PROTOBUF = "application/x-protobuf",
    MULTIPART_FORM_DATA = "multipart/form-data",
    MULTIPART_MIXED = "multipart/mixed",
    MULTIPART_ALTERNATIVE = "multipart/alternative",
    MULTIPART_DIGEST = "multipart/digest",
    MULTIPART_RELATED = "multipart/related",
    MULTIPART_SIGNED = "multipart/signed",
    MULTIPART_ENCRYPTED = "multipart/encrypted",
    OCTET_STREAM = "application/octet-stream",
    PDF = "application/pdf",
    ZIP = "application/zip",
    GZIP = "application/gzip",
    MSWORD = "application/msword",
    DOCX = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    EXCEL = "application/vnd.ms-excel",
    XLSX = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    POWERPOINT = "application/vnd.ms-powerpoint",
    PPTX = "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ICO = "image/x-icon",
    ICO_MS = "image/vnd.microsoft.icon",
    GIF = "image/gif",
    PNG = "image/png",
    JPEG = "image/jpeg",
    WEBP = "image/webp",
    SVG = "image/svg+xml",
    HEIF = "image/heif",
    AVIF = "image/avif",
    EVENT_STREAM = "text/event-stream",
    TAR = "application/x-tar",
    BZIP2 = "application/x-bzip2"
}

/**
 * Time constants in seconds. Month is approximated as 30 days.
 */
declare const Time: {
    readonly Second: 1;
    readonly Minute: 60;
    readonly Hour: 3600;
    readonly Day: 86400;
    readonly Week: 604800;
    readonly Month: 2592000;
    readonly Year: 31536000;
};

/**
 * Type guard that checks if a string is a valid HTTP method.
 *
 * @param value - The string to test.
 * @returns True if \`value\` is a recognized HTTP method.
 */
declare function isMethod(value: unknown): value is Method;
/**
 * Checks if a value is an array of valid HTTP methods.
 *
 * Each element is verified using the \`isMethod\` type guard.
 *
 * @param value - The value to check.
 * @returns \`true\` if \`value\` is an array and every element is a valid \`Method\`, otherwise \`false\`.
 */
declare function isMethodArray(value: unknown): value is Method[];
/**
 * Asserts that a value is an array of valid HTTP methods.
 *
 * This function uses {@link isMethodArray} to validate the input. If the
 * value is not an array of \`Method\` elements, it throws a \`TypeError\`.
 * Otherwise, TypeScript will narrow the type of \`value\` to \`Method[]\`
 * within the calling scope.
 *
 * @param value - The value to check.
 * @throws TypeError If \`value\` is not a valid method array.
 */
declare function assertMethods(value: unknown): asserts value is Method[];

/**
 * User-supplied options for configuring CORS behavior.
 *
 * This is a partial form of {@link CorsConfig}, meaning you only need
 * to provide the options you want to override. Any missing values will
 * fall back to the {@link defaultCorsConfig}.
 *
 * Example:
 * \`\`\`ts
 * const cors: CorsInit = {
 *   allowedOrigins: ["https://example.com"],
 *   allowCredentials: true,
 * };
 * \`\`\`
 */
type CorsInit = Partial<CorsConfig>;
/**
 * Configuration options for Cross-Origin Resource Sharing (CORS).
 *
 * Implementations of CORS middleware use this interface to determine
 * how cross-origin requests are validated and which headers are sent
 * in the response.
 *
 * @default
 * \`\`\`ts
 * {
 *   allowedOrigins: ["*"],
 *   allowedHeaders: ["Content-Type"],
 *   exposedHeaders: [],
 *   allowCredentials: false,
 *   maxAge: 300, // 5 minutes
 * }
 * \`\`\`
 */
interface CorsConfig {
    /**
     * Origins allowed for CORS requests.
     *
     * Use \`["*"]\` to allow all origins, or provide a list of specific origins.
     * Example: \`["https://example.com", "https://api.example.com"]\`
     *
     * @default ["*"]
     */
    allowedOrigins: string[];
    /**
     * HTTP headers allowed in CORS requests.
     *
     * Browsers always allow *CORS-safelisted request headers* without preflight:
     * - \`Accept\`
     * - \`Accept-Language\`
     * - \`Content-Language\`
     * - \`Content-Type\` (but only if its value is \`application/x-www-form-urlencoded\`,
     *   \`multipart/form-data\`, or \`text/plain\`)
     *
     * Because \`Content-Type\` is only partially safelisted, it is included in the
     * default allowed headers.
     *
     * Add custom headers here (e.g., \`Authorization\`) if your clients send them.
     *
     * @default ["Content-Type"]
     */
    allowedHeaders: string[];
    /**
     * HTTP headers exposed to the client.
     *
     * By default, most headers are not accessible from client-side JavaScript.
     * Use this option to explicitly allow certain response headers to be read.
     *
     * @default []
     */
    exposedHeaders: string[];
    /**
     * Whether the resource supports user credentials (cookies, HTTP authentication).
     *
     * If true, the Access-Control-Allow-Origin response header must not be "*".
     *
     * @default false
     */
    allowCredentials: boolean;
    /**
     * Maximum age (in seconds) that the results of a preflight request
     * can be cached by the client.
     *
     * Increase for production use to reduce preflights, or lower for development
     * if you frequently adjust CORS rules.
     *
     * @default 300 (5 minutes)
     */
    maxAge: number;
}

/**
 * Structure for JSON-formatted error responses.
 *
 * This interface defines the standard shape of error responses returned
 * when an operation fails. It ensures consistent error reporting and easy
 * parsing by clients.
 */
interface ErrorJson {
    /**
     * HTTP status code associated with the error.
     *
     * Example: \`404\` for Not Found, \`500\` for Internal Server Error.
     */
    status: number;
    /**
     * Standard HTTP reason phrase corresponding to the status code.
     *
     * Example: \`"Not Found"\` for 404, \`"Internal Server Error"\` for 500.
     */
    error: string;
    /**
     * Optional detailed message describing the error.
     *
     * This can include additional context, debugging hints, or
     * information useful to the client. Will be an empty string
     * if no details are provided.
     */
    details: string;
}

/**
 * Represents the constructor of a Worker subclass.
 *
 * @template T - The specific type of Worker being constructed. Defaults to \`Worker\`.
 * @param req - The \`Request\` object to be handled by the worker instance.
 * @param env - The environment bindings available to the worker.
 * @param ctx - The \`ExecutionContext\` for the worker invocation.
 * @returns An instance of the worker type \`T\`.
 */
type WorkerClass<T extends Worker = Worker> = new (request: Request, env: Env, ctx: ExecutionContext) => T;
/**
 * Defines the contract for a Cloudflare-compatible Worker.
 *
 * Implementations are responsible for handling incoming requests,
 * providing access to the request, environment bindings, and
 * execution context.
 */
interface Worker {
    /**
     * Processes the incoming {@link Request} and produces a {@link Response}.
     *
     * @returns A Promise that resolves to the HTTP {@link Response}.
     */
    fetch(): Promise<Response>;
    /**
     * The original {@link Request} being processed by this worker instance.
     */
    get request(): Request;
    /**
     * The environment bindings provided at runtime (e.g., KV, R2, secrets).
     */
    get env(): Env;
    /**
     * The {@link ExecutionContext} associated with the current request,
     * used to manage background tasks and request lifecycle.
     */
    get ctx(): ExecutionContext;
    /**
     * Returns the list of HTTP methods that are allowed for this worker.
     *
     * @returns An array of allowed HTTP methods.
     */
    getAllowedMethods(): Method[];
}

/**
 * Parameters extracted from a matched route.
 *
 * The keys correspond to named parameters in the route's path pattern,
 * and the values are the strings captured from the URL.
 *
 * @example
 * // For a route defined as "/users/:userId/posts/:postId"
 * // and a URL "/users/42/posts/7", the extracted PathParams would be:
 * const params: PathParams = {
 *   userId: "42",
 *   postId: "7"
 * };
 */
type PathParams = Record<string, string>;
/**
 * Type for a route callback function.
 *
 * Route callbacks are executed when a request matches a route.
 *
 * @param params - Named parameters extracted from the URL path.
 * @returns A Response object or a Promise resolving to a Response.
 */
type RouteCallback = (params: PathParams) => Response | Promise<Response>;
/**
 * A handler for a route, which can be either:
 *
 * 1. \`RouteCallback\` function that receives the route
 *    parameters and returns a \`Response\` or \`Promise<Response>\`.
 * 2. \`WorkerClass\` (subclass of \`Worker\`) that will handle
 *    the request by instantiating a new worker.
 */
type RouteHandler = RouteCallback | WorkerClass;
/**
 * Represents a single route.
 *
 * Contains all necessary information to match an incoming request and
 * pass to the registered handler.
 */
interface Route {
    /** HTTP method for the route (e.g., GET, POST, etc.) */
    method: Method;
    /** Path-to-regexp matcher function for this route */
    matcher: MatchFunction<PathParams>;
    /** Function or Worker to execute or instantiate when the route is matched */
    handler: RouteHandler;
}
/**
 * Result of a route match.
 *
 * Returned by routing logic when a request matches a route pattern.
 */
interface MatchedRoute {
    /** The route that matched the request */
    route: Route;
    /** Parameters extracted from the URL path */
    params: PathParams;
}
/**
 * A route tuple. Each tuple consists of:
 *
 * 1. HTTP method (e.g., "GET", "POST")
 * 2. Path string (supports parameters, e.g., "/users/:id")
 * 3. Callback function or Worker class to handle matched requests
 * */
type RouteTuple = [Method, string, RouteHandler];
/**
 * Iterable of route tuples, used to populate a \`Routes\` object.
 *
 * Each item yields a {@link RouteTuple} representing a single route.
 *
 * @see {@link RouteTuple}
 */
type RouteTable = Iterable<RouteTuple>;

/**
 * Abstract base class for middleware.
 *
 * Middleware classes implement request/response processing logic in a
 * chainable manner. Each middleware receives a \`Worker\` object and a
 * \`next\` function that invokes the next middleware in the chain.
 *
 * Subclasses **must implement** the \`handle\` method.
 *
 * Example subclass:
 * \`\`\`ts
 * class LoggingMiddleware extends Middleware {
 *     public async handle(worker: Worker, next: () => Promise<Response>): Promise<Response> {
 *         console.log(\`Processing request: \${worker.request.url}\`);
 *         const response = await next();
 *         console.log(\`Response status: \${response.status}\`);
 *         return response;
 *      }
 * }
 * \`\`\`
 */
declare abstract class Middleware {
    /**
     * Process a request in the middleware chain.
     *
     * @param worker - The \`Worker\` instance representing the request context.
     * @param next - Function to invoke the next middleware in the chain.
     *               Must be called to continue the chain unless the middleware
     *               terminates early (e.g., returns a response directly).
     * @returns A \`Response\` object, either returned directly or from \`next()\`.
     */
    abstract handle(worker: Worker, next: () => Promise<Response>): Promise<Response>;
}

/**
 * Creates a Vary-aware caching middleware for Workers.
 *
 * This middleware:
 * - Caches **GET requests** only.
 * - Respects the \`Vary\` header of responses, ensuring that requests
 *   with different headers (e.g., \`Origin\`) receive the correct cached response.
 * - Skips caching for non-cacheable responses (e.g., error responses or
 *   responses with \`Vary: *\`).
 *
 * @param cacheName Optional name of the cache to use. If omitted, the default cache is used.
 * @param getKey Optional function to compute a custom cache key from a request.
 *               If omitted, the request URL is normalized and used as the key.
 * @returns A \`Middleware\` instance that can be used in a Worker pipeline.
 */
declare function cache(cacheName?: string, getKey?: (request: Request) => URL): Middleware;

/**
 * Creates a CORS middleware instance.
 *
 * This middleware automatically handles Cross-Origin Resource Sharing (CORS)
 * for incoming requests, including preflight OPTIONS requests, and adds
 * appropriate headers to responses.
 *
 * @param init - Optional configuration for CORS behavior. See {@link CorsConfig}.
 * @returns A {@link Middleware} instance that can be used in your middleware chain.
 */
declare function cors(init?: CorsInit): Middleware;

/**
 * Lexicographically compares two strings.
 *
 * This comparator can be used in \`Array.prototype.sort()\` to produce a
 * consistent, stable ordering of string arrays.
 *
 * @param a - The first string to compare.
 * @param b - The second string to compare.
 * @returns A number indicating the relative order of \`a\` and \`b\`.
 */
declare function lexCompare(a: string, b: string): number;

/**
 * Sets a header on the given Headers object.
 *
 * - If \`value\` is an array, any duplicates and empty strings are removed.
 * - If the resulting value is empty, the header is deleted.
 * - Otherwise, values are joined with \`", "\` and set as the header value.
 *
 * @param headers - The Headers object to modify.
 * @param key - The header name to set.
 * @param value - The header value(s) to set. Can be a string or array of strings.
 */
declare function setHeader(headers: Headers, key: string, value: string | string[]): void;
/**
 * Merges new value(s) into an existing header on the given Headers object.
 *
 * - Preserves any existing values and adds new ones.
 * - Removes duplicates and trims all values.
 * - If the header does not exist, it is created.
 * - If the resulting value array is empty, the header is deleted.
 *
 * @param headers - The Headers object to modify.
 * @param key - The header name to merge into.
 * @param value - The new header value(s) to add. Can be a string or array of strings.
 */
declare function mergeHeader(headers: Headers, key: string, value: string | string[]): void;
/**
 * Returns the values of an HTTP header as an array of strings.
 *
 * This helper:
 * - Retrieves the header value by \`key\`.
 * - Splits the value on commas.
 * - Trims surrounding whitespace from each entry.
 * - Filters out any empty tokens.
 * - Removes duplicate values (case-sensitive)
 *
 * If the header is not present, an empty array is returned.
 *
 */
declare function getHeaderValues(headers: Headers, key: string): string[];

/**
 * Extracts and normalizes the \`Origin\` header from a request.
 *
 * Returns the origin (scheme + host + port) as a string if present and valid.
 * Returns \`null\` if:
 *   - The \`Origin\` header is missing
 *   - The \`Origin\` header is \`"null"\` (opaque origin)
 *   - The \`Origin\` header is malformed
 *
 * @param request - The incoming {@link Request} object.
 * @returns The normalized origin string, or \`null\` if not present or invalid.
 */
declare function getOrigin(request: Request): string | null;
/**
 * Returns a new URL with its query parameters sorted into a stable order.
 *
 * This is useful for cache key generation: URLs that differ only in the
 * order of their query parameters will normalize to the same key.
 *
 * @param request - The incoming Request whose URL will be normalized.
 * @returns A new URL with query parameters sorted by name.
 */
declare function sortSearchParams(request: Request): URL;
/**
 * Returns a new URL with all query parameters removed.
 *
 * This is useful when query parameters are not relevant to cache lookups,
 * ensuring that variants of the same resource share a single cache entry.
 *
 * @param request - The incoming Request whose URL will be normalized.
 * @returns A new URL with no query parameters.
 */
declare function stripSearchParams(request: Request): URL;

/**
 * Returns the proper Content-Type string for a given media type.
 * Appends \`charset=utf-8\` for text-based types that require it.
 *
 * @param type - The media type.
 * @returns A string suitable for the \`Content-Type\` header.
 */
declare function getContentType(type: MediaType): string;

/**
 * A type-safe Cloudflare Worker handler with a guaranteed \`fetch\` method.
 *
 * Extends \`ExportedHandler\` but ensures that \`fetch\` exists and has the
 * correct signature for Cloudflare Worker invocation.
 *
 * \`Env\` is a placeholder type for the environment bindings provided by
 * the user (e.g., KV namespaces, secrets, Durable Objects). This interface
 * does not constrain the actual type; it only ensures \`fetch\` is present.
 */
interface FetchHandler extends ExportedHandler<Env> {
    /**
     * Handles an incoming request and produces a response.
     *
     * @param request - The incoming \`Request\` object.
     * @param env - User-provided environment bindings (placeholder type).
     * @param ctx - Execution context for background tasks (\`waitUntil\`).
     * @returns A \`Promise\` that resolves to a \`Response\`.
     */
    fetch: (request: Request, env: Env, ctx: ExecutionContext) => Promise<Response>;
}

/**
 * Provides the foundational structure for handling requests,
 * environment bindings, and the worker execution context.
 *
 * Features:
 * - Holds the current \`Request\` object (\`request\` getter).
 * - Provides access to environment bindings (\`env\` getter).
 * - Provides access to the worker execution context (\`ctx\` getter).
 * - Subclasses must implement \`fetch()\` to process the request.
 */
declare abstract class BaseWorker implements Worker {
    private readonly _request;
    private readonly _env;
    private readonly _ctx;
    constructor(_request: Request, _env: Env, _ctx: ExecutionContext);
    /** The Request object associated with this worker invocation */
    get request(): Request;
    /** Environment bindings (e.g., KV, secrets, or other globals) */
    get env(): Env;
    /** Execution context for background tasks or \`waitUntil\` */
    get ctx(): ExecutionContext;
    /**
     * Dispatches the incoming request to the appropriate handler and produces a response.
     *
     * Subclasses must implement this method to define how the worker generates a \`Response\`
     * for the current request. This is the central point where request processing occurs.
     *
     * @returns A Promise that resolves to the \`Response\` for the request.
     */
    protected abstract dispatch(): Promise<Response>;
    /**
     * Checks if the given HTTP method is allowed for this worker.
     * @param method HTTP method string
     * @returns true if the method is allowed
     */
    isAllowed(method: string): boolean;
    abstract getAllowedMethods(): Method[];
    /**
     * Creates a new instance of the current Worker subclass.
     *
     * @param request - The {@link Request} to pass to the new worker instance.
     * @returns A new worker instance of the same subclass as \`this\`.
     */
    protected create(request: Request): this;
    /**
     * Process the {@link Request} and produce a {@link Response}.
     *
     * @returns A {@link Response} promise for the {@link Request}.
     */
    abstract fetch(): Promise<Response>;
    /**
     * Simplify and standardize {@link Response} creation by extending {@link WorkerResponse}
     * or any of its subclasses and passing to this method.
     *
     * Or directly use any of the built-in classes.
     *
     * \`\`\`ts
     * this.getResponse(TextResponse, "Hello World!")
     * \`\`\`
     *
     * @param ResponseClass The response class to instantiate
     * @param args Additional constructor arguments
     * @returns A Promise resolving to the {@link Response} object
     */
    protected getResponse<Ctor extends new (...args: any[]) => {
        getResponse(): Promise<Response>;
    }>(ResponseClass: Ctor, ...args: ConstructorParameters<Ctor>): Promise<Response>;
    /**
     * **Ignite** your \`Worker\` implementation into a Cloudflare handler.
     *
     * @returns A \`FetchHandler\` that launches a new worker instance for each request.
     *
     * \`\`\`ts
     * export default MyWorker.ignite();
     * \`\`\`
     */
    static ignite<W extends Worker>(this: WorkerClass<W>): FetchHandler;
}

/** Internal base worker for handling middleware chains. */
declare abstract class MiddlewareWorker extends BaseWorker {
    /** Middleware handlers registered for this worker. */
    protected readonly middlewares: Middleware[];
    /**
     * Hook for subclasses to perform any initialization.
     */
    protected init(): void | Promise<void>;
    /**
     * Add a middleware instance to this worker.
     *
     * The middleware will run for every request handled by this worker,
     * in the order they are added.
     *
     * @param handler - The middleware to run.
     * @returns \`this\` to allow chaining multiple \`.use()\` calls.
     */
    use(handler: Middleware): this;
    /**
     * Executes the middleware chain and dispatches the request.
     *
     * @returns The Response produced by the last middleware or \`dispatch()\`.
     */
    fetch(): Promise<Response>;
}

/**
 * Basic worker class providing HTTP method dispatching and error handling.
 */
declare abstract class BasicWorker extends MiddlewareWorker {
    /**
     * Entry point to handle a fetch request.
     */
    fetch(): Promise<Response>;
    /**
     * Dispatches the request to the method-specific handler.
     */
    protected dispatch(): Promise<Response>;
    /** Override and implement this method for GET requests. */
    protected get(): Promise<Response>;
    /** Override and implement this method for PUT requests. */
    protected put(): Promise<Response>;
    /** Override and implement this method for POST requests. */
    protected post(): Promise<Response>;
    /** Override and implement this method for PATCH requests. */
    protected patch(): Promise<Response>;
    /** Override and implement this method for DELETE requests. */
    protected delete(): Promise<Response>;
    /** Returns a default empty OPTIONS response. */
    protected options(): Promise<Response>;
    /**
     * Default handler for HEAD requests.
     * Performs a GET request and removes the body for HEAD semantics.
     *
     * Usually does not need to be overridden as this behavior covers
     * standard HEAD requirements.
     */
    protected head(): Promise<Response>;
    /**
     * DEFAULT allowed HTTP methods for subclasses.
     *
     * These defaults were selected for getting started quickly and should be
     * overridden for each specific worker.
     */
    getAllowedMethods(): Method[];
}

/**
 * Base worker supporting route-based request handling.
 *
 * Subclass \`RouteWorker\` to define a worker with multiple route handlers.
 *
 * Routes can be registered individually via \`route()\` or in bulk via \`routes()\`.
 */
declare abstract class RouteWorker extends BasicWorker {
    /** Internal table of registered routes. */
    private readonly _routes;
    /**
     * Registers a single new route in the worker.
     *
     * When a request matches the specified method and path, the provided handler
     * will be executed. The handler can be either:
     * - A function that receives URL parameters, or
     * - A Worker subclass that will handle the request.
     *
     * @param method  - HTTP method for the route (GET, POST, etc.).
     * @param path    - URL path pattern (Express-style, e.g., "/users/:id").
     * @param handler - The function or Worker class to run when the route matches.
     * @returns The current worker instance, allowing method chaining.
     */
    protected route(method: Method, path: string, handler: RouteHandler): this;
    /**
     * Registers multiple routes at once in the worker.
     *
     * Each route should be a tuple \`[method, path, handler]\` where:
     * - \`method\`  - HTTP method for the route (GET, POST, etc.).
     * - \`path\`    - URL path pattern (Express-style, e.g., "/users/:id").
     * - \`handler\` - A function that receives URL parameters or a Worker subclass
     *               that will handle the request.
     *
     * @param routes - An iterable of routes to register. Each item is a \`[method, path, handler]\` tuple.
     * @returns The current worker instance, allowing method chaining.
     */
    protected routes(routes: RouteTable): this;
    /**
     * Matches the incoming request against registered routes and dispatches it.
     *
     * If a route is found:
     * - If the handler is a Worker class, a new instance is created and its \`fetch()\` is called.
     * - If the handler is a callback function, it is invoked with the extracted path parameters.
     *
     * If no route matches, the request is passed to the parent \`dispatch()\` handler.
     *
     * @returns A \`Promise<Response>\` from the matched handler or parent dispatch.
     */
    protected dispatch(): Promise<Response>;
    /**
     * Runtime type guard to check if a given handler is a Worker class.
     *
     * A Worker class is any class that extends \`BaseWorker\`.
     *
     * @param handler - The constructor function to test.
     * @returns \`true\` if \`handler\` is a subclass of \`BaseWorker\` at runtime, \`false\` otherwise.
     */
    private static isWorkerClass;
    protected get(): Promise<Response>;
    protected put(): Promise<Response>;
    protected post(): Promise<Response>;
    protected patch(): Promise<Response>;
    protected delete(): Promise<Response>;
}

/**
 * Base class for building HTTP responses.
 * Manages headers, status, and media type.
 */
declare abstract class BaseResponse {
    /** HTTP headers for the response. */
    headers: Headers;
    /** HTTP status code (default 200 OK). */
    status: StatusCodes;
    /** Optional status text. Defaults to standard reason phrase. */
    statusText?: string;
    /** Enable websocket responses. */
    webSocket: WebSocket | null;
    /** Default media type of the response body. */
    mediaType: MediaType;
    /** Converts current state to ResponseInit for constructing a Response. */
    protected get responseInit(): ResponseInit;
    /** Sets a header, overwriting any existing value. */
    setHeader(key: string, value: string | string[]): void;
    /** Merges a header with existing values (does not overwrite). */
    mergeHeader(key: string, value: string | string[]): void;
    /** Adds a Content-Type header if not already existing (does not overwrite). */
    addContentType(): void;
}
/**
 * Base response class that adds caching headers.
 */
declare abstract class CacheResponse extends BaseResponse {
    cache?: CacheControl | undefined;
    constructor(cache?: CacheControl | undefined);
    /** Adds Cache-Control header if caching is configured. */
    protected addCacheHeader(): void;
}
/**
 * Core worker response. Combines caching, and security headers.
 */
declare abstract class WorkerResponse extends CacheResponse {
    private readonly body;
    constructor(body?: BodyInit | null, cache?: CacheControl);
    /** Builds the Response object with body, headers, and status. */
    getResponse(): Promise<Response>;
}
/**
 * Wraps an existing Response and clones its body, headers, and status.
 */
declare class ClonedResponse extends WorkerResponse {
    constructor(response: Response, cache?: CacheControl);
}
/**
 * Represents a successful response with customizable body, cache and status.
 */
declare class SuccessResponse extends WorkerResponse {
    constructor(body?: BodyInit | null, cache?: CacheControl, status?: StatusCodes);
}
/**
 * JSON response. Automatically sets Content-Type to application/json.
 */
declare class JsonResponse extends SuccessResponse {
    constructor(json?: unknown, cache?: CacheControl, status?: StatusCodes);
}
/**
 * HTML response. Automatically sets Content-Type to text/html.
 */
declare class HtmlResponse extends SuccessResponse {
    constructor(body: string, cache?: CacheControl, status?: StatusCodes);
}
/**
 * Plain text response. Automatically sets Content-Type to text/plain.
 */
declare class TextResponse extends SuccessResponse {
    constructor(content: string, cache?: CacheControl, status?: StatusCodes);
}
/**
 * Response for WebSocket upgrade requests.
 * Automatically sets status to 101 and attaches the client socket.
 */
declare class WebSocketResponse extends WorkerResponse {
    constructor(client: WebSocket);
}
/**
 * Response for HEAD requests. Copy headers and status from a GET response
 * without the body.
 */
declare class Head extends WorkerResponse {
    constructor(get: Response);
}
/**
 * Response for OPTIONS preflight requests.
 */
declare class Options extends SuccessResponse {
    constructor();
}

/**
 * Generic HTTP error response.
 * Sends a JSON body with status, error message, and details.
 */
declare class HttpError extends JsonResponse {
    protected readonly details?: string | undefined;
    /**
     * @param worker The worker handling the request.
     * @param status HTTP status code.
     * @param details Optional detailed error message.
     */
    constructor(status: StatusCodes, details?: string | undefined);
}
/** 400 Bad Request error response. */
declare class BadRequest extends HttpError {
    constructor(details?: string);
}
/** 401 Unauthorized error response. */
declare class Unauthorized extends HttpError {
    constructor(details?: string);
}
/** 403 Forbidden error response. */
declare class Forbidden extends HttpError {
    constructor(details?: string);
}
/** 404 Not Found error response. */
declare class NotFound extends HttpError {
    constructor(details?: string);
}
/** 405 Method Not Allowed error response. */
declare class MethodNotAllowed extends HttpError {
    constructor(worker: Worker);
}
/** 426 Upgrade Required error response. */
declare class UpgradeRequired extends HttpError {
    constructor();
}
/** 500 Internal Server Error response. */
declare class InternalServerError extends HttpError {
    constructor(details?: string);
}
/** 501 Not Implemented error response. */
declare class NotImplemented extends HttpError {
    constructor(details?: string);
}
/** 501 Method Not Implemented error response for unsupported HTTP methods. */
declare class MethodNotImplemented extends NotImplemented {
    constructor(worker: Worker);
}
/** 503 Service Unavailable error response. */
declare class ServiceUnavailable extends HttpError {
    constructor(details?: string);
}

export { BadRequest, BasicWorker, CacheControl, ClonedResponse, type CorsConfig, type CorsInit, DELETE, type ErrorJson, Forbidden, GET, HEAD, Head, HtmlResponse, HttpError, HttpHeader, InternalServerError, JsonResponse, type MatchedRoute, MediaType, Method, MethodNotAllowed, MethodNotImplemented, Middleware, NotFound, NotImplemented, OPTIONS, Options, PATCH, POST, PUT, type PathParams, type Route, type RouteCallback, type RouteHandler, type RouteTable, type RouteTuple, RouteWorker, ServiceUnavailable, SuccessResponse, TextResponse, Time, Unauthorized, UpgradeRequired, WebSocketResponse, type Worker, type WorkerClass, WorkerResponse, assertMethods, cache, cors, getContentType, getHeaderValues, getOrigin, isMethod, isMethodArray, lexCompare, mergeHeader, setHeader, sortSearchParams, stripSearchParams };
"
`;
