// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`library export tests > matches the exported symbols snapshot 1`] = `
[
  "BadRequest",
  "BasicWorker",
  "CacheControl",
  "ClonedResponse",
  "DELETE",
  "Forbidden",
  "GET",
  "HEAD",
  "Head",
  "HtmlResponse",
  "HttpError",
  "HttpHeader",
  "InternalServerError",
  "JsonResponse",
  "MediaType",
  "Method",
  "MethodNotAllowed",
  "MethodNotImplemented",
  "Middleware",
  "NotFound",
  "NotImplemented",
  "OPTIONS",
  "Options",
  "PATCH",
  "POST",
  "PUT",
  "RouteWorker",
  "ServiceUnavailable",
  "StatusCodes",
  "SuccessResponse",
  "TextResponse",
  "Time",
  "Unauthorized",
  "WorkerResponse",
  "cache",
  "cors",
  "getContentType",
  "getOrigin",
  "isMethod",
  "lexCompare",
  "mergeHeader",
  "normalizeUrl",
  "setHeader",
]
`;

exports[`library export tests > matches the index.d.ts snapshot 1`] = `
"import CacheLib from 'cache-control-parser';
import { StatusCodes } from 'http-status-codes';
export { StatusCodes } from 'http-status-codes';
import { MatchFunction } from 'path-to-regexp';

/**
 * @see {@link https://github.com/etienne-martin/cache-control-parser | cache-control-parser}
 */
type CacheControl = CacheLib.CacheControl;
declare const CacheControl: {
    parse: (cacheControlHeader: string) => CacheLib.CacheControl;
    stringify: (cacheControl: CacheLib.CacheControl) => string;
    /** A Cache-Control directive that disables all caching. */
    DISABLE: Readonly<{
        "no-cache": true;
        "no-store": true;
        "must-revalidate": true;
        "max-age": 0;
    }>;
};

/**
 * Standard HTTP header names and common values.
 */
declare namespace HttpHeader {
    const VARY = "Vary";
    const ALLOW = "Allow";
    const USER_AGENT = "User-Agent";
    const CONTENT_TYPE = "Content-Type";
    const CACHE_CONTROL = "Cache-Control";
    const SEC_FETCH_SITE = "Sec-Fetch-Site";
    const X_FRAME_OPTIONS = "X-Frame-Options";
    const X_CONTENT_TYPE_OPTIONS = "X-Content-Type-Options";
    const REFERRER_POLICY = "Referrer-Policy";
    const PERMISSIONS_POLICY = "Permissions-Policy";
    const CONTENT_SECURITY_POLICY = "Content-Security-Policy";
    const STRICT_TRANSPORT_SECURITY = "Strict-Transport-Security";
    const MAX_AGE = "Access-Control-Max-Age";
    const ALLOW_ORIGIN = "Access-Control-Allow-Origin";
    const ALLOW_HEADERS = "Access-Control-Allow-Headers";
    const ALLOW_METHODS = "Access-Control-Allow-Methods";
    const EXPOSE_HEADERS = "Access-Control-Expose-Headers";
    const ALLOW_CREDENTIALS = "Access-Control-Allow-Credentials";
    const ORIGIN = "Origin";
    const ALLOW_ALL_ORIGINS = "*";
    const CROSS_SITE = "cross-site";
}
/**
 * Time constants in seconds. Month is approximated as 30 days.
 */
declare const Time: {
    readonly Second: 1;
    readonly Minute: 60;
    readonly Hour: 3600;
    readonly Day: 86400;
    readonly Week: 604800;
    readonly Month: 2592000;
    readonly Year: 31536000;
};
/**
 * Standard HTTP request methods.
 */
declare enum Method {
    GET = "GET",
    PUT = "PUT",
    HEAD = "HEAD",
    POST = "POST",
    PATCH = "PATCH",
    DELETE = "DELETE",
    OPTIONS = "OPTIONS"
}
/**
 * Shorthand constants for each HTTP method.
 *
 * These are equivalent to the corresponding enum members in \`Method\`.
 * For example, \`GET === Method.GET\`.
 */
declare const GET: Method;
declare const PUT: Method;
declare const HEAD: Method;
declare const POST: Method;
declare const PATCH: Method;
declare const DELETE: Method;
declare const OPTIONS: Method;
/**
 * Type guard that checks if a string is a valid HTTP method.
 *
 * @param value - The string to test.
 * @returns True if \`value\` is a recognized HTTP method.
 */
declare function isMethod(value: string): value is Method;
/**
 * Returns the proper Content-Type string for a given media type.
 * Appends \`charset=utf-8\` for text-based types that require it.
 *
 * @param type - The media type.
 * @returns A string suitable for the \`Content-Type\` header.
 */
declare function getContentType(type: MediaType): string;
/**
 * Common media types used for HTTP headers.
 */
declare enum MediaType {
    PLAIN_TEXT = "text/plain",
    HTML = "text/html",
    CSS = "text/css",
    CSV = "text/csv",
    XML = "text/xml",
    MARKDOWN = "text/markdown",
    RICH_TEXT = "text/richtext",
    JSON = "application/json",
    XML_APP = "application/xml",
    YAML = "application/x-yaml",
    FORM_URLENCODED = "application/x-www-form-urlencoded",
    NDJSON = "application/x-ndjson",
    MSGPACK = "application/x-msgpack",
    PROTOBUF = "application/x-protobuf",
    MULTIPART_FORM_DATA = "multipart/form-data",
    MULTIPART_MIXED = "multipart/mixed",
    MULTIPART_ALTERNATIVE = "multipart/alternative",
    MULTIPART_DIGEST = "multipart/digest",
    MULTIPART_RELATED = "multipart/related",
    MULTIPART_SIGNED = "multipart/signed",
    MULTIPART_ENCRYPTED = "multipart/encrypted",
    OCTET_STREAM = "application/octet-stream",
    PDF = "application/pdf",
    ZIP = "application/zip",
    GZIP = "application/gzip",
    MSWORD = "application/msword",
    DOCX = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    EXCEL = "application/vnd.ms-excel",
    XLSX = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    POWERPOINT = "application/vnd.ms-powerpoint",
    PPTX = "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ICO = "image/x-icon",
    ICO_MS = "image/vnd.microsoft.icon",
    GIF = "image/gif",
    PNG = "image/png",
    JPEG = "image/jpeg",
    WEBP = "image/webp",
    SVG = "image/svg+xml",
    HEIF = "image/heif",
    AVIF = "image/avif",
    EVENT_STREAM = "text/event-stream",
    TAR = "application/x-tar",
    BZIP2 = "application/x-bzip2"
}
/**
 * Sets a header on the given Headers object.
 *
 * - If \`value\` is an array, any duplicates and empty strings are removed.
 * - If the resulting value array is empty, the header is deleted.
 * - Otherwise, values are joined with \`", "\` and set as the header value.
 *
 * @param headers - The Headers object to modify.
 * @param key - The header name to set.
 * @param value - The header value(s) to set. Can be a string or array of strings.
 */
declare function setHeader(headers: Headers, key: string, value: string | string[]): void;
/**
 * Merges new value(s) into an existing header on the given Headers object.
 *
 * - Preserves any existing values and adds new ones.
 * - Removes duplicates and trims all values.
 * - If the header does not exist, it is created.
 *
 * @param headers - The Headers object to modify.
 * @param key - The header name to merge into.
 * @param value - The new header value(s) to add. Can be a string or array of strings.
 */
declare function mergeHeader(headers: Headers, key: string, value: string | string[]): void;
/**
 * Normalizes a URL string for use as a consistent cache key.
 *
 * - Sorts query parameters alphabetically so \`?b=2&a=1\` and \`?a=1&b=2\` are treated the same.
 * - Strips fragment identifiers (\`#...\`) since they are not sent in HTTP requests.
 * - Leaves protocol, host, path, and query values intact.
 *
 * @param url The original URL string to normalize.
 * @returns A normalized URL string suitable for hashing or direct cache key use.
 */
declare function normalizeUrl(url: string): URL;
/**
 * Lexicographically compares two strings.
 *
 * This comparator can be used in \`Array.prototype.sort()\` to produce a
 * consistent, stable ordering of string arrays.
 *
 * @param a - The first string to compare.
 * @param b - The second string to compare.
 * @returns A number indicating the relative order of \`a\` and \`b\`.
 */
declare function lexCompare(a: string, b: string): number;
/**
 * Extracts the \`Origin\` header value from a request.
 *
 * The \`Origin\` header identifies the origin (scheme, host, and port)
 * of the request initiator. It is commonly used for CORS checks.
 *
 * @param request - The incoming {@link Request} object.
 * @returns The origin string if present, otherwise \`null\`.
 */
declare function getOrigin(request: Request): string | null;

/**
 * Base class for building HTTP responses.
 * Manages headers, status, and media type.
 */
declare abstract class BaseResponse {
    constructor();
    /** HTTP headers for the response. */
    headers: Headers;
    /** HTTP status code (default 200 OK). */
    status: StatusCodes;
    /** Optional status text. Defaults to standard reason phrase. */
    statusText?: string;
    /** Default media type of the response body. */
    mediaType: MediaType;
    /** Converts current state to ResponseInit for constructing a Response. */
    protected get responseInit(): ResponseInit;
    /** Sets a header, overwriting any existing value. */
    setHeader(key: string, value: string | string[]): void;
    /** Merges a header with existing values (does not overwrite). */
    mergeHeader(key: string, value: string | string[]): void;
    /** Adds a Content-Type header if not already existing (does not overwrite). */
    addContentType(): void;
}
/**
 * Base response class that adds caching headers.
 */
declare abstract class CacheResponse extends BaseResponse {
    cache?: CacheControl | undefined;
    constructor(cache?: CacheControl | undefined);
    /** Adds Cache-Control header if caching is configured. */
    protected addCacheHeader(): void;
}
/**
 * Core worker response. Combines caching, and security headers.
 */
declare abstract class WorkerResponse extends CacheResponse {
    private readonly body;
    constructor(body?: BodyInit | null, cache?: CacheControl);
    /** Builds the Response object with body, headers, and status. */
    getResponse(): Promise<Response>;
}
/**
 * Wraps an existing Response and clones its body, headers, and status.
 */
declare class ClonedResponse extends WorkerResponse {
    constructor(response: Response, cache?: CacheControl);
}
/**
 * Represents a successful response with customizable body and status.
 */
declare class SuccessResponse extends WorkerResponse {
    constructor(body?: BodyInit | null, cache?: CacheControl, status?: StatusCodes);
}
/**
 * JSON response. Automatically sets Content-Type to application/json.
 */
declare class JsonResponse extends SuccessResponse {
    constructor(json?: unknown, cache?: CacheControl, status?: StatusCodes);
}
/**
 * HTML response. Automatically sets Content-Type to text/html.
 */
declare class HtmlResponse extends SuccessResponse {
    constructor(body: string, cache?: CacheControl, status?: StatusCodes);
}
/**
 * Plain text response. Automatically sets Content-Type to text/plain.
 */
declare class TextResponse extends SuccessResponse {
    constructor(content: string, cache?: CacheControl, status?: StatusCodes);
}
/**
 * Response for HEAD requests. Clones headers but has no body.
 */
declare class Head extends WorkerResponse {
    constructor(get: Response);
}
/**
 * Response for OPTIONS preflight requests.
 * Sets CORS headers and returns 204 No Content.
 */
declare class Options extends SuccessResponse {
    constructor();
}

/**
 * Represents the constructor of a Worker subclass.
 *
 * @template T - The specific type of Worker being constructed. Defaults to \`Worker\`.
 * @param req - The \`Request\` object to be handled by the worker instance.
 * @param env - The environment bindings available to the worker.
 * @param ctx - The \`ExecutionContext\` for the worker invocation.
 * @returns An instance of the worker type \`T\`.
 */
type WorkerClass<T extends Worker = Worker> = new (request: Request, env: Env, ctx: ExecutionContext) => T;
/**
 * Defines the contract for a Cloudflare-compatible Worker.
 *
 * Implementations are responsible for handling incoming requests,
 * providing access to the request, environment bindings, and
 * execution context.
 */
interface Worker {
    /**
     * Processes the incoming {@link Request} and produces a {@link Response}.
     *
     * @returns A Promise that resolves to the HTTP {@link Response}.
     */
    fetch(): Promise<Response>;
    /**
     * The original {@link Request} being processed by this worker instance.
     */
    get request(): Request;
    /**
     * The environment bindings provided at runtime (e.g., KV, R2, secrets).
     */
    get env(): Env;
    /**
     * The {@link ExecutionContext} associated with the current request,
     * used to manage background tasks and request lifecycle.
     */
    get ctx(): ExecutionContext;
    /**
     * Returns the list of HTTP methods that are allowed for this worker.
     *
     * @returns {Method[]} An array of allowed HTTP methods.
     */
    getAllowedMethods(): Method[];
}

/**
 * Generic HTTP error response.
 * Sends a JSON body with status, error message, and details.
 */
declare class HttpError extends JsonResponse {
    protected readonly details?: string | undefined;
    /**
     * @param worker The worker handling the request.
     * @param status HTTP status code.
     * @param details Optional detailed error message.
     */
    constructor(status: StatusCodes, details?: string | undefined);
}
/** 400 Bad Request error response. */
declare class BadRequest extends HttpError {
    constructor(details?: string);
}
/** 401 Unauthorized error response. */
declare class Unauthorized extends HttpError {
    constructor(details?: string);
}
/** 403 Forbidden error response. */
declare class Forbidden extends HttpError {
    constructor(details?: string);
}
/** 404 Not Found error response. */
declare class NotFound extends HttpError {
    constructor(details?: string);
}
/** 405 Method Not Allowed error response. */
declare class MethodNotAllowed extends HttpError {
    constructor(worker: Worker);
}
/** 500 Internal Server Error response. */
declare class InternalServerError extends HttpError {
    constructor(details?: string);
}
/** 501 Not Implemented error response. */
declare class NotImplemented extends HttpError {
    constructor(details?: string);
}
/** 501 Method Not Implemented error response for unsupported HTTP methods. */
declare class MethodNotImplemented extends NotImplemented {
    constructor(worker: Worker);
}
/** 503 Service Unavailable error response. */
declare class ServiceUnavailable extends HttpError {
    constructor(details?: string);
}

/**
 * Override only what is needed from the default CORS configuration.
 */
type CorsInit = Partial<CorsConfig>;
/**
 * Configuration options for Cross-Origin Resource Sharing (CORS).
 *
 * Implementations of CORS middleware use this interface to determine
 * how cross-origin requests are validated and which headers are sent
 * in the response.
 */
interface CorsConfig {
    /**
     * Origins allowed for CORS requests.
     *
     * Use \`["*"]\` to allow all origins, or provide a list of specific origins.
     * Example: \`["https://example.com", "https://api.example.com"]\`
     */
    allowedOrigins: string[];
    /**
     * HTTP headers allowed in CORS requests.
     *
     * Requests that include headers not listed here will be blocked
     * during the preflight check.
     */
    allowedHeaders: string[];
    /**
     * HTTP headers exposed to the client.
     *
     * By default, most headers are not accessible from client-side JavaScript.
     * Use this option to explicitly allow certain response headers to be read.
     */
    exposedHeaders: string[];
    /**
     * Maximum age (in seconds) that the results of a preflight request
     * can be cached by the client.
     *
     * Example: \`60 * 60 * 24 * 7\` (1 week).
     */
    maxAge: number;
}

/**
 * Structure for JSON-formatted error responses.
 *
 * This interface defines the standard shape of error responses returned
 * by middleware or workers when an operation fails. It ensures consistent
 * error reporting and easy parsing by clients.
 */
interface ErrorJson {
    /**
     * HTTP status code associated with the error.
     *
     * Example: \`404\` for Not Found, \`500\` for Internal Server Error.
     */
    status: number;
    /**
     * Standard HTTP reason phrase corresponding to the status code.
     *
     * Example: \`"Not Found"\` for 404, \`"Internal Server Error"\` for 500.
     */
    error: string;
    /**
     * Optional detailed message describing the error.
     *
     * This can include additional context, debugging hints, or
     * information useful to the client. Will be an empty string
     * if no details are provided.
     */
    details: string;
}

/**
 * Parameters extracted from a matched route.
 *
 * The keys correspond to named parameters in the route's path pattern,
 * and the values are the strings captured from the URL.
 *
 * @example
 * // For a route defined as "/users/:userId/posts/:postId"
 * // and a URL "/users/42/posts/7", the extracted PathParams would be:
 * const params: PathParams = {
 *   userId: "42",
 *   postId: "7"
 * };
 */
type PathParams = Record<string, string>;
/**
 * Type for a route callback function.
 *
 * Route callbacks are executed when a request matches a route.
 *
 * @param params - Named parameters extracted from the URL path.
 * @returns A Response object or a Promise resolving to a Response.
 */
type RouteCallback = (params: PathParams) => Response | Promise<Response>;
/**
 * A handler for a route, which can be either:
 *
 * 1. \`RouteCallback\` function that receives the route
 *    parameters and returns a \`Response\` or \`Promise<Response>\`.
 * 2. \`WorkerClass\` (subclass of \`Worker\`) that will handle
 *    the request by instantiating a new worker.
 */
type RouteHandler = RouteCallback | WorkerClass;
/**
 * Represents a single route.
 *
 * Contains all necessary information to match an incoming request and
 * pass to the registered handler.
 */
interface Route {
    /** HTTP method for the route (e.g., GET, POST, etc.) */
    method: Method;
    /** Path-to-regexp matcher function for this route */
    matcher: MatchFunction<PathParams>;
    /** Function or Worker to execute or instantiate when the route is matched */
    handler: RouteHandler;
}
/**
 * Result of a route match.
 *
 * Returned by routing logic when a request matches a route pattern.
 */
interface MatchedRoute {
    /** The route that matched the request */
    route: Route;
    /** Parameters extracted from the URL path */
    params: PathParams;
}
/**
 * A route tuple. Each tuple consists of:
 *
 * 1. HTTP method (e.g., "GET", "POST")
 * 2. Path string (supports parameters, e.g., "/users/:id")
 * 3. Callback function or Worker class to handle matched requests
 * */
type RouteTuple = [Method, string, RouteHandler];
/**
 * Iterable of route tuples, used to populate a \`Routes\` object.
 *
 * Each item yields a {@link RouteTuple} representing a single route.
 *
 * @see {@link RouteTuple}
 */
type RouteTable = Iterable<RouteTuple>;

/**
 * Abstract base class for middleware.
 *
 * Middleware classes implement request/response processing logic in a
 * chainable manner. Each middleware receives a \`Worker\` object and a
 * \`next\` function that invokes the next middleware in the chain.
 *
 * Subclasses **must implement** the \`handle\` method.
 *
 * Example subclass:
 * \`\`\`ts
 * class LoggingMiddleware extends Middleware {
 *     public async handle(worker: Worker, next: () => Promise<Response>): Promise<Response> {
 *         console.log(\`Processing request: \${worker.request.url}\`);
 *         const response = await next();
 *         console.log(\`Response status: \${response.status}\`);
 *         return response;
 *      }
 * }
 * \`\`\`
 */
declare abstract class Middleware {
    /**
     * Process a request in the middleware chain.
     *
     * @param worker - The \`Worker\` instance representing the request context.
     * @param next - Function to invoke the next middleware in the chain.
     *               Must be called to continue the chain unless the middleware
     *               terminates early (e.g., returns a response directly).
     * @returns A \`Response\` object, either returned directly or from \`next()\`.
     */
    abstract handle(worker: Worker, next: () => Promise<Response>): Promise<Response>;
}

/**
 * Creates a CORS middleware instance.
 *
 * This middleware automatically handles Cross-Origin Resource Sharing (CORS)
 * for incoming requests, including preflight OPTIONS requests, and adds
 * appropriate headers to responses.
 *
 * @param init - Optional configuration for CORS behavior. See {@link CorsConfig}.
 * @returns A {@link Middleware} instance that can be used in your middleware chain.
 */
declare function cors(init?: CorsInit): Middleware;

/**
 * Middleware for caching GET requests.
 *
 * This middleware checks a cache (either a named cache or the default)
 * before passing the request down the middleware chain. Responses for
 * successful GET requests are automatically stored in the cache.
 *
 * Non-GET requests are never cached. The cache key can be customized
 * via the \`getKey\` function; otherwise, the URL is normalized and used.
 *
 * @param cacheName - Optional name of the cache to use. Defaults to \`caches.default\`.
 * @param getKey - Optional function to generate a cache key from a request.
 * @returns A {@link Middleware} instance that can be added to your middleware chain.
 * \`\`\`
 */
declare function cache(cacheName?: string, getKey?: (request: Request) => URL | RequestInfo): Middleware;

/**
 * A type-safe Cloudflare Worker handler.
 *
 * Extends \`ExportedHandler\` but guarantees that the \`fetch\` method exists
 * and has the correct signature for Cloudflare Worker invocation.
 *
 * @template E - The type of environment bindings passed to the worker. Defaults to \`Env\`.
 */
interface FetchHandler extends ExportedHandler<Env> {
    /**
     * Handles an incoming request and produces a response.
     *
     * @param request - The incoming \`Request\` object.
     * @param env - Environment bindings (e.g., KV namespaces, secrets, Durable Objects).
     * @param ctx - Execution context for background tasks (\`waitUntil\`).
     * @returns A \`Promise\` that resolves to the response.
     */
    fetch: (request: Request, env: Env, ctx: ExecutionContext) => Promise<Response>;
}

/**
 * Provides the foundational structure for handling requests,
 * environment bindings, and the worker execution context.
 *
 * Features:
 * - Holds the current \`Request\` object (\`request\` getter).
 * - Provides access to environment bindings (\`env\` getter).
 * - Provides access to the worker execution context (\`ctx\` getter).
 * - Subclasses must implement \`fetch()\` to process the request.
 */
declare abstract class BaseWorker implements Worker {
    private readonly _request;
    private readonly _env;
    private readonly _ctx;
    constructor(_request: Request, _env: Env, _ctx: ExecutionContext);
    /** The Request object associated with this worker invocation */
    get request(): Request;
    /** Environment bindings (e.g., KV, secrets, or other globals) */
    get env(): Env;
    /** Execution context for background tasks or \`waitUntil\` */
    get ctx(): ExecutionContext;
    /**
     * Dispatches the incoming request to the appropriate handler and produces a response.
     *
     * Subclasses must implement this method to define how the worker generates a \`Response\`
     * for the current request. This is the central point where request processing occurs.
     *
     * @returns A Promise that resolves to the \`Response\` for the request.
     */
    protected abstract dispatch(): Promise<Response>;
    abstract getAllowedMethods(): Method[];
    /**
     * Creates a new instance of the current Worker subclass.
     *
     * @param request - The {@link Request} to pass to the new worker instance.
     * @returns A new worker instance of the same subclass as \`this\`.
     */
    protected create(request: Request): this;
    /**
     * Process the {@link Request} and produce a {@link Response}.
     *
     * @returns A {@link Response} promise for the {@link Request}.
     */
    abstract fetch(): Promise<Response>;
    /**
     * **Ignite** your \`Worker\` implementation into a Cloudflare handler.
     *
     * @returns A \`FetchHandler\` that launches a new worker instance for each request.
     *
     * \`\`\`ts
     * export default MyWorker.ignite();
     * \`\`\`
     */
    static ignite<W extends Worker>(this: WorkerClass<W>): FetchHandler;
}

/** Internal base worker for handling middleware chains. */
declare abstract class MiddlewareWorker extends BaseWorker {
    /** Middleware handlers registered for this worker. */
    protected readonly middlewares: Middleware[];
    /**
     * Add a middleware instance to this worker.
     *
     * The middleware will run for every request handled by this worker,
     * in the order they are added.
     *
     * @param handler - The middleware to run.
     * @returns \`this\` to allow chaining multiple \`.use()\` calls.
     */
    use(handler: Middleware): this;
    /**
     * Executes the middleware chain and dispatches the request.
     *
     * @returns The Response produced by the last middleware or \`dispatch()\`.
     */
    fetch(): Promise<Response>;
}

/**
 * Basic worker class providing HTTP method dispatching and error handling.
 */
declare abstract class BasicWorker extends MiddlewareWorker {
    /**
     * Entry point to handle a fetch request.
     */
    fetch(): Promise<Response>;
    /**
     * Dispatches the request to the method-specific handler.
     */
    protected dispatch(): Promise<Response>;
    /**
     * Hook for subclasses to perform any initialization.
     */
    protected init(): void | Promise<void>;
    /**
     * Checks if the given HTTP method is allowed for this worker.
     * @param method HTTP method string
     * @returns true if the method is allowed
     */
    isAllowed(method: string): boolean;
    /** Override and implement this method for GET requests. */
    protected get(): Promise<Response>;
    /** Override and implement this method for PUT requests. */
    protected put(): Promise<Response>;
    /** Override and implement this method for POST requests. */
    protected post(): Promise<Response>;
    /** Override and implement this method for PATCH requests. */
    protected patch(): Promise<Response>;
    /** Override and implement this method for DELETE requests. */
    protected delete(): Promise<Response>;
    /** Override and implement this method for OPTIONS requests. */
    protected options(): Promise<Response>;
    /**
     * Default handler for HEAD requests.
     * Performs a GET request and removes the body for HEAD semantics.
     *
     * Usually does not need to be overridden as this behavior covers
     * standard HEAD requirements.
     */
    protected head(): Promise<Response>;
    /**
     * DEFAULT allowed HTTP methods for subclasses.
     *
     * These defaults were selected for getting started quickly and should be
     * overridden for each specific worker.
     */
    getAllowedMethods(): Method[];
    /**
     * Simplify and standardize {@link Response} creation by extending {@link WorkerResponse}
     * or any of its subclasses and passing to this method.
     *
     * Or directly use any of the built-in classes.
     *
     * \`\`\`ts
     * this.getResponse(TextResponse, "Hello World!")
     * \`\`\`
     *
     * @param ResponseClass The response class to instantiate
     * @param args Additional constructor arguments
     * @returns A Promise resolving to the {@link Response} object
     */
    protected getResponse<Ctor extends new (...args: any[]) => {
        getResponse(): Promise<Response>;
    }>(ResponseClass: Ctor, ...args: ConstructorParameters<Ctor>): Promise<Response>;
}

/**
 * Base worker supporting route-based request handling.
 *
 * Subclass \`RouteWorker\` to define a worker with multiple route handlers.
 *
 * Routes can be registered individually via \`route()\` or in bulk via \`routes()\`.
 */
declare abstract class RouteWorker extends BasicWorker {
    /** Internal table of registered routes. */
    private readonly _routes;
    /**
     * Registers a single new route in the worker.
     *
     * When a request matches the specified method and path, the provided handler
     * will be executed. The handler can be either:
     * - A function that receives URL parameters, or
     * - A Worker subclass that will handle the request.
     *
     * @param method  - HTTP method for the route (GET, POST, etc.).
     * @param path    - URL path pattern (Express-style, e.g., "/users/:id").
     * @param handler - The function or Worker class to run when the route matches.
     * @returns The current worker instance, allowing method chaining.
     */
    protected route(method: Method, path: string, handler: RouteHandler): this;
    /**
     * Registers multiple routes at once in the worker.
     *
     * Each route should be a tuple \`[method, path, handler]\` where:
     * - \`method\`  - HTTP method for the route (GET, POST, etc.).
     * - \`path\`    - URL path pattern (Express-style, e.g., "/users/:id").
     * - \`handler\` - A function that receives URL parameters or a Worker subclass
     *               that will handle the request.
     *
     * @param routes - An iterable of routes to register. Each item is a \`[method, path, handler]\` tuple.
     * @returns The current worker instance, allowing method chaining.
     */
    protected routes(routes: RouteTable): this;
    /**
     * Matches the incoming request against registered routes and dispatches it.
     *
     * If a route is found:
     * - If the handler is a Worker class, a new instance is created and its \`fetch()\` is called.
     * - If the handler is a callback function, it is invoked with the extracted path parameters.
     *
     * If no route matches, the request is passed to the parent \`dispatch()\` handler.
     *
     * @returns A \`Promise<Response>\` from the matched handler or parent dispatch.
     */
    protected dispatch(): Promise<Response>;
    /**
     * Runtime type guard to check if a given handler is a Worker class.
     *
     * A Worker class is any class that extends \`BaseWorker\`.
     *
     * @param handler - The constructor function to test.
     * @returns \`true\` if \`handler\` is a subclass of \`BaseWorker\` at runtime, \`false\` otherwise.
     */
    private static isWorkerClass;
    protected get(): Promise<Response>;
    protected put(): Promise<Response>;
    protected post(): Promise<Response>;
    protected patch(): Promise<Response>;
    protected delete(): Promise<Response>;
    protected options(): Promise<Response>;
}

export { BadRequest, BasicWorker, CacheControl, ClonedResponse, type CorsConfig, type CorsInit, DELETE, type ErrorJson, Forbidden, GET, HEAD, Head, HtmlResponse, HttpError, HttpHeader, InternalServerError, JsonResponse, type MatchedRoute, MediaType, Method, MethodNotAllowed, MethodNotImplemented, Middleware, NotFound, NotImplemented, OPTIONS, Options, PATCH, POST, PUT, type PathParams, type Route, type RouteCallback, type RouteHandler, type RouteTable, type RouteTuple, RouteWorker, ServiceUnavailable, SuccessResponse, TextResponse, Time, Unauthorized, type Worker, type WorkerClass, WorkerResponse, cache, cors, getContentType, getOrigin, isMethod, lexCompare, mergeHeader, normalizeUrl, setHeader };
"
`;
